
<div class="place-details">
  <h3>{ name }</h3>

  <div class="place-index">
      <Histogram
        figureClass="metro-index-chart"
        title="Metro area cities ranked by hot housing index"
        noLabel="{ true }"
        noCaption="{ true }"
        xHide="{ true }"
        xLabel="Ranking"
        yLabel="Index"
        yMin="0"
        colors="{ [metroColor, placeColor] }"
        dataConfig="{{
          xs: {
            'Index': 'Ranking',
            'Place': 'Ranking'
          },
          columns: [
            ['Ranking'].concat(ranked.map(d => d.i)),
            ['Index'].concat(ranked.map(d => d.index))
          ],
          color: indexChartColorWrapper(id, ranked, metroColor, placeColor),
          type: 'bar'
        }}"
        redraw="{ true }"
      >Chart showing each city in the Twin Cities area metro and where they fall on the Star Tribune Hot Housing Index.</Histogram>
  </div>

  <div class="row">
    <div class="col col-66">
      <p class="data-copy">
        Located in <span>{ county } County</span>,
        <span>{ name }</span>

        {#if rank}
          ranked <span><strong>{ rank }</strong></span> on the Star Tribune's Hot Housing Index for 2018.
        {:else}
          <span><strong>was not included</strong></span> in the Star Tribune's Hot Housing Index for 2018 due to an insufficent number of sales.
        {/if}

        {#if pricePerSqFtChange || pricePerSqFtChange === 0}
          Average price per square foot was
          {#if pricePerSqFtChange === 0}
            about the same
          {:else}
            { pricePerSqFtChange > 0 ? 'up' : 'down' }
            <span>{ formatPercent(pricePerSqFtChange) } percent</span>
          {/if}
          compared to previous four-year average.
        {/if}

        {#if daysOnMarketChange || daysOnMarketChange === 0}
          Houses sold, on average,
          {#if daysOnMarketChange === 0}
            about the same when compared to the previous year.
          {:else}
            <span>{  Math.abs(Math.round(daysOnMarketChange)) } days { daysOnMarketChange > 0 ? 'slower' : 'faster' }</span>
            than the previous year.
          {/if}
        {/if}

        {#if perPriceRecieved || perPriceRecieved === 0}
          Sellers got, on average, <span>{ formatPercent(perPriceRecieved) } percent</span> of their original list price.
        {/if}

        {#if perNewConstruction || perNewConstruction === 0}
          About <span>{ formatPercent(perNewConstruction) } percent</span> of the <span>{ closedSales.toLocaleString() }</span> sales were from new construction and <span>{ formatPercent(perDistressed) } percent</span> were short sales or foreclosures.
        {/if}
      </p>

      {#if cityId && cityId !== id}
        <p class="data-copy">Located in <a href="#place-{ cityId }" on:click="goToPlace(cityId, event)">{ placeName(cityId, places) }</a></p>
      {/if}

      {#if neighborhoods && neighborhoods.length}
        Includes neighborhoods:
        {#each neighborhoods as n, ni (n.id)}
          <a href="#place-{ n.id }" on:click="goToPlace(n.id, event)">{ placeName(n.id, places, name) }</a>{#if ni < neighborhoods.length - 1},{@html "&#32;"}{/if}
        {/each}
      {/if}
    </div>

    <div class="col col-33">
      <figure>
        <div class="placeholder placeholder-chart">Locator map</div>
        <figcaption>Caption...</figcaption>
      </figure>
    </div>
  </div>

  <h4 class="market-hed">Real-estate market data</h4>

  <div class="row">
    <div class="col col-50">
      <Line
        title="Average price per square foot"
        xLabel="Year"
        yLabel="Price per square foot"
        yMin="0"
        colors="{ [placeColor, metroColor] }"
        dataConfig="{{
          xs: {
            'Place': 'Year',
            'Metro': 'Year'
          },
          columns: [
            ['Year'].concat(pricePerSqFtPerYear.map(d => d.year)),
            ['Place'].concat(pricePerSqFtPerYear.map(d => d.data)),
            ['Metro'].concat(metro.pricePerSqFtPerYear.map(d => d.data))
          ]
        }}"
      />
    </div>

    <div class="col col-50">
      <Line
        title="Average days on market"
        xLabel="Year"
        yLabel="Days on market"
        yMin="0"
        colors="{ [placeColor, metroColor] }"
        dataConfig="{{
          xs: {
            'Place': 'Year',
            'Metro': 'Year'
          },
          columns: [
            ['Year'].concat(daysOnMarketPerYear.map(d => d.year)),
            ['Place'].concat(daysOnMarketPerYear.map(d => d.data)),
            ['Metro'].concat(metro.daysOnMarketPerYear.map(d => d.data))
          ]
        }}"
      />
    </div>
  </div>

  <div class="row">
    <div class="col col-50">
      <Line
        title="Closed sales by year for { name }"
        xLabel="Year"
        yLabel="Closed sales"
        hideLegend="{ true }"
        yMin="0"
        colors="{ [placeColor, metroColor] }"
        dataConfig="{{
          xs: {
            'Closed sales': 'Year'
          },
          columns: [
            ['Year'].concat(closedPerYear.map(d => d.year)),
            ['Closed sales'].concat(closedPerYear.map(d => d.data))
          ]
        }}"
      />
    </div>

    <div class="col col-50">
      <Line
        title="Inventory for { name }"
        xLabel="Year"
        yLabel="Inventory"
        hideLegend="{ true }"
        yMin="0"
        colors="{ [placeColor, metroColor] }"
        dataConfig="{{
          xs: {
            'Inventory': 'Year'
          },
          columns: [
            ['Year'].concat(inventoryPerYear.map(d => d.year)),
            ['Inventory'].concat(inventoryPerYear.map(d => d.data))
          ]
        }}"
      />
    </div>
  </div>

  <h4 class="about-hed">About this place</h4>

  {#if !medianHomeValue && !medianHouseholdIncome && !perOwnerOccupied && !perCostBurdened}
    <p>Demographic and Census data not available for this area.</p>
  {/if}

  {#if stats}
    <div class="row">
      <div class="col col-100 col-md-50">
        {#if medianHomeValue}
          <Histogram
            title="Median value of owner-occupied homes"
            xLabel="Median home value"
            yLabel="Number of places"
            yHide="{ true }"
            yMin="0"
            yMax="{ maxBy(stats.medianHomeValue.histogram, 'count').count * 1.15 }"
            xMin="0"
            xMax="{ stats.medianHomeValue.max * 1.05 }"
            colors="{ [metroColor, placeColor] }"
            dataConfig="{{
              xs: {
                'Number of places': 'Median home value'
              },
              columns: [
                ['Median home value'].concat(stats.medianHomeValue.histogram.map(d => (d.min + d.max) / 2)),
                ['Number of places'].concat(stats.medianHomeValue.histogram.map(d => d.count))
              ],
              type: 'bar'
            }}"
            xTickFormat="{ d => { return `$${Math.round(d / 1000).toLocaleString()}k`; }}"
            lineAnnotationOptions="{ medianHomeValue ? (chart) => {
              return {
                x1: chart.internal.x(medianHomeValue),
                y1: chart.internal.y(maxBy(stats.medianHomeValue.histogram, 'count').count * 1.15),
                x2: chart.internal.x(medianHomeValue),
                y2: chart.internal.y(0),
                textx: chart.internal.x(medianHomeValue) + 3,
                texty: chart.internal.y(maxBy(stats.medianHomeValue.histogram, 'count').count * 1.05),
                // text: name
              }
            } : undefined }"
            redraw="{ true }"
          >
            {#if medianHomeValue}
              Median home value in { name } is ${ medianHomeValue.toLocaleString() }
            {/if}
          </Histogram>
        {/if}
      </div>

      <div class="col col-100 col-md-50">
        {#if medianHouseholdIncome}
          <Histogram
            title="Median household income"
            xLabel="Median household income"
            yLabel="Number of places"
            yHide="{ true }"
            yMin="0"
            yMax="{ maxBy(stats.medianHouseholdIncome.histogram, 'count').count * 1.15 }"
            xMin="{ stats.medianHouseholdIncome.min * 0.95 }"
            xMax="{ stats.medianHouseholdIncome.max * 1.05 }"
            colors="{ [metroColor, placeColor] }"
            dataConfig="{{
              xs: {
                'Number of places': 'Median household income'
              },
              columns: [
                ['Median household income'].concat(stats.medianHouseholdIncome.histogram.map(d => (d.min + d.max) / 2)),
                ['Number of places'].concat(stats.medianHouseholdIncome.histogram.map(d => d.count))
              ],
              type: 'bar'
            }}"
            xTickFormat="{ d => { return `$${Math.round(d / 1000)}k`; }}"
            lineAnnotationOptions="{ medianHouseholdIncome ? (chart) => {
              return {
                x1: chart.internal.x(medianHouseholdIncome),
                y1: chart.internal.y(maxBy(stats.medianHouseholdIncome.histogram, 'count').count * 1.15),
                x2: chart.internal.x(medianHouseholdIncome),
                y2: chart.internal.y(0),
                textx: chart.internal.x(medianHouseholdIncome) + 3,
                texty: chart.internal.y(maxBy(stats.medianHouseholdIncome.histogram, 'count').count * 1.05),
                //text: name
              }
            } : undefined }"
            redraw="{ true }"
          >
            {#if medianHouseholdIncome}
              Median household income in { name } is ${ medianHouseholdIncome.toLocaleString() }
            {/if}
          </Histogram>
        {/if}
      </div>

      <div class="col col-100 col-md-50">
        {#if perOwnerOccupied}
          <Histogram
            title="Percent owner-occupied homes"
            xLabel="Percent owner-occupied homes"
            yLabel="Number of places"
            yHide="{ true }"
            yMin="0"
            yMax="{ maxBy(stats.perOwnerOccupied.histogram, 'count').count * 1.15 }"
            xMin="0"
            xMax="1"
            colors="{ [metroColor, placeColor] }"
            dataConfig="{{
              xs: {
                'Number of places': 'Percent owner-occupied homes'
              },
              columns: [
                ['Percent owner-occupied homes'].concat(stats.perOwnerOccupied.histogram.map(d => (d.min + d.max) / 2)),
                ['Number of places'].concat(stats.perOwnerOccupied.histogram.map(d => d.count))
              ],
              type: 'bar'
            }}"
            xTickFormat="{ d => { return `${Math.round(d * 100)}%`; }}"
            lineAnnotationOptions="{ perOwnerOccupied ? (chart) => {
              return {
                x1: chart.internal.x(perOwnerOccupied),
                y1: chart.internal.y(maxBy(stats.perOwnerOccupied.histogram, 'count').count * 1.15),
                x2: chart.internal.x(perOwnerOccupied),
                y2: chart.internal.y(0),
                textx: chart.internal.x(perOwnerOccupied) + 3,
                texty: chart.internal.y(maxBy(stats.perOwnerOccupied.histogram, 'count').count * 1.05),
                //text: name
              }
            } : undefined }"
            redraw="{ true }"
          >
            {#if perOwnerOccupied}
              Percent owner-occupied homes in { name } is { Math.round(perOwnerOccupied * 10000) / 100 }%
            {/if}
          </Histogram>
        {/if}
      </div>

      <div class="col col-100 col-md-50">
        {#if perCostBurdened}
          <Histogram
            title="Percent cost-burdened owners"
            xLabel="Percent cost-burdened owners"
            yLabel="Number of places"
            yHide="{ true }"
            yMin="0"
            yMax="{ maxBy(stats.perCostBurdened.histogram, 'count').count * 1.15 }"
            xMin="0"
            xMax="{ stats.perCostBurdened.max * 1.1 }"
            colors="{ [metroColor, placeColor] }"
            dataConfig="{{
              xs: {
                'Number of places': 'Percent cost-burdened owners'
              },
              columns: [
                ['Percent cost-burdened owners'].concat(stats.perCostBurdened.histogram.map(d => (d.min + d.max) / 2)),
                ['Number of places'].concat(stats.perCostBurdened.histogram.map(d => d.count))
              ],
              type: 'bar'
            }}"
            xTickFormat="{ d => { return `${Math.round(d * 100)}%`; }}"
            lineAnnotationOptions="{ perCostBurdened ? (chart) => {
              return {
                x1: chart.internal.x(perCostBurdened),
                y1: chart.internal.y(maxBy(stats.perCostBurdened.histogram, 'count').count * 1.15),
                x2: chart.internal.x(perCostBurdened),
                y2: chart.internal.y(0),
                textx: chart.internal.x(perCostBurdened) + 3,
                texty: chart.internal.y(maxBy(stats.perCostBurdened.histogram, 'count').count * 1.05),
                //text: name
              }
            } : undefined }"
            redraw="{ true }"
          >
            {#if perCostBurdened}
              Percent cost-burdened owners in { name } is { Math.round(perCostBurdened * 10000) / 100 }%
            {/if}
          </Histogram>
        {/if}
      </div>
    </div>
  {/if}
</div>

<script>
  import Histogram from "./_chart-histogram.svelte.html";
  import Line from "./_chart-line.svelte.html";
  import { isNumber, maxBy, find, filter, minBy } from "lodash";

  export default {
    components: {
      Histogram,
      Line
    },

    oncreate() {},

    methods: {
      goToPlace(placeId, event) {
        if (event && event.preventDefault) {
          event.preventDefault();
        }

        if (this.root && this.root.setPlace) {
          this.root.setPlace(placeId);
        }
      }
    },

    computed: {
      neighborhoods({ id, places }) {
        if (!id || !places) {
          return;
        }

        return filter(places, a => {
          return a.cityId === id && a.cityId !== a.id;
        });
      }
    },

    helpers: {
      maxBy,
      minBy,

      // Max with some padding
      padMax(collection, prop) {
        let f = maxBy(collection, prop);
        return f ? Math.floor(f[prop] * 1.2) : undefined;
      },

      formatPercent(input) {
        if (!isNumber(input)) {
          return "-";
        }

        input = input * 100;
        if (input < 1 && input > 0) {
          return "less than 1";
        } else if (input > -1 && input < 0) {
          return "less than 1";
        }

        return Math.round(input);
      },

      indexChartColorWrapper(id, ranked, metroColor, placeColor) {
        return (c, d, a) => {
          return ranked[d.index] && ranked[d.index].id === id
            ? placeColor
            : metroColor;
        };
      },

      placeName(placeId, places, name) {
        if (!placeId || !places) {
          return "";
        }

        let a = find(places, { id: placeId });
        if (a) {
          return name ? a.name.replace(`(${name})`, "").trim() : a.name;
        }
      }
    },

    data() {
      return {};
    }
  };
</script>
